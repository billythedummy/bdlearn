#include <iostream>
#include "BConv_basic.hpp"

using namespace bdlearn;

int test_BConv_rand_constructor() {
    int k = 13;
    int in_c = 3;
    int out_c = 5;
    BConvLayer dut (k, 1, in_c, out_c);
    for (int out_c_i = 0; out_c_i < out_c; ++out_c_i) {
        for (int in_c_i = 0; in_c_i < in_c; ++in_c_i) {
            for (int y = 0; y < k; ++y) {
                for (int x = 0; x < k; ++x) {
                    if (dut.get_w(x, y, in_c_i, out_c_i)
                        != (dut.get_train_w(x, y, in_c_i, out_c_i) >= 0)) {
                        std::cerr << "test_BConv_rand_constructor failed at " << out_c_i << ", " << in_c_i << ", " << y << ", " << x;
                        std::cerr << ". Expected: " << (dut.get_train_w(x, y, in_c_i, out_c_i) >= 0) << ", got: " << dut.get_w(x, y, in_c_i, out_c_i) << std::endl;
                        return -1;
                    }
                }
            }
        }
    }
    return 0;
}

int test_forward_t() {
    int k = 13;
    int in_c = 3;
    int out_c = 5;
    BConvLayer dut (k, 1, in_c, out_c);

    int m = 120; 
    int n = 100;
    float* res = new float[m*n*in_c];
    Halide::Buffer<float> res_buf(res, m, n, "res_buf");
    
    const int out_height = (m - k) / 1 + 1;
    const int out_width = (n - k) / 1 + 1;
    const int patch_area = k* k;
    const int h_im2col = patch_area * in_c;
    const int w_im2col = out_height * out_width;

    float out[out_c * w_im2col];
    Halide::Buffer<float> out_buf(res, out_c, w_im2col, "out_buf");
    std::cout << out_c << w_im2col << std::endl;
    std::cout << 
        res_buf.dim(1).extent() << " " <<
        res_buf.dim(0).extent() << " " <<
        dut.get_rows() << " " <<
        dut.get_cols() << " " <<
        out_buf.dim(1).extent() << " " <<
        out_buf.dim(0).extent() << std::endl;
    dut.forward_t(out_buf, res_buf);
    delete res;
    return 0;
}

int test_BConv_forward_backward() {
    const int s = 1;
    const int k = 3;
    const int width = 4;
    const int height = 5;
    const int out_height = (height - k) / s + 1;
    const int out_width = (width - k) / s + 1;
    const int in_c = 3;
    const int out_c = 4;
    const int batch = 2;
    float out [batch * out_c * out_height * out_width];
    Halide::Buffer<float> out_view(out, out_width, out_height, out_c, batch);
    float in [batch * in_c * width * height] = {
        -1.00865331, -0.29219059,  2.67323418,  1.8020211 ,  0.06334328,
       -0.93614211, -0.0566484 ,  0.10741072, -0.35934454, -2.38577151,
       -1.12968527, -1.73120435, -0.99528351,  0.14717974,  1.10746035,
        0.12275506, -1.23225989, -0.91246136,  0.57759139,  0.14330837,
        0.19972974,  0.23643302,  1.78377793, -1.63716193, -0.71179966,
        0.94430747,  1.31911213, -0.84233116,  0.11643658, -1.69246736,
       -1.64737212,  1.08346985, -0.06631668, -0.62604917,  0.52611927,
       -0.31612989, -1.61702444,  0.99476058, -0.55800325,  2.00426533,
        3.442167  , -1.02430882,  0.09381595, -0.7679083 ,  2.014368  ,
       -0.07990519, -0.20638353,  0.87695587, -2.87695277,  0.63686711,
       -0.37224111,  0.30792107,  0.47311558,  0.53818892, -1.02746744,
       -0.42890086, -0.3766753 ,  0.13679642, -0.32584462,  0.19585104,
        0.70778735, -2.49214661, -0.97716056, -0.81333065, -2.03955354,
        0.63255747, -0.58223596,  0.74004346,  0.9673292 ,  1.05641445,
        0.32640769,  0.16965868,  0.06097121, -0.37424648,  0.83535751,
       -0.22970285, -1.29852304,  1.60117816, -0.4266019 ,  0.03812115,
       -1.62695264, -0.45039727, -0.89233058, -0.34620122, -0.3616281 ,
        1.45834436,  0.92573991, -1.25538252, -0.58039008, -0.04393592,
        0.11642086,  0.0212527 ,  0.32238868, -0.70639151, -0.53507394,
       -0.08731686, -0.2609255 , -0.42632088,  1.02653768, -0.54569219,
        0.14520752, -0.79650049, -1.3959103 , -1.21162863,  0.37943659,
       -1.84386534, -2.54894931,  0.00668073, -0.36955124,  1.77577916,
        0.46833654, -0.22232106, -1.01085293, -0.0624432 ,  1.02065703,
       -1.22657194, -0.26174993,  0.0906495 ,  2.52473708,  1.67438017
    };
    float W [k*k*in_c*out_c] = {
        -0.7299722 , -0.78967849,  0.84872669, -0.49856974, -1.09713458,
        1.47446225, -0.48514377, -0.12391957, -0.32268059,  0.34577184,
       -1.07259811,  1.85186512, -1.43826704,  0.37966712,  0.77195291,
        0.08796895, -0.51668848,  0.61286801,  0.59773526, -1.09789223,
       -0.57357792, -0.49615405, -0.61383422, -0.87604905, -0.12136966,
        0.84372212,  2.14358485,  0.30483449,  1.00991064,  0.38306488,
        0.59696656,  0.87319798, -0.06306927, -1.4817166 ,  2.28488271,
       -0.9710247 ,  0.32753392,  1.54709241, -0.1421556 ,  0.52972941,
       -0.85173797,  0.2514344 ,  1.38198671,  0.56488595, -0.27808375,
        0.30079492, -1.5604293 , -0.76920338,  0.94884777, -0.34898017,
       -0.27261119,  0.66253144, -0.44718849, -1.04649192, -0.40443405,
        0.75018633,  0.76379933, -0.18070994,  1.69631008,  0.95052768,
       -0.49252714,  0.09670723,  1.18107807, -0.60567241, -1.61544695,
       -0.70376182, -0.53966195, -0.38910442, -0.14767869, -0.32604882,
        0.03504815,  0.53011946,  0.99830563,  0.2980226 ,  0.18446012,
        0.35257727, -0.39835519,  1.29643823, -0.18279839, -0.80132703,
       -0.13609081,  0.35219595, -0.58026604,  1.25114061,  0.59609455,
       -0.49310708,  0.03367772, -0.29258327, -0.46005861, -2.14134511,
        0.38816264, -2.92246895,  1.87465183, -0.43234896,  0.94031102,
       -0.13359161, -0.59917379, -1.22028055,  1.16533403, -0.71487912,
       -0.13869648, -0.72062408, -0.01038284, -1.82785722,  0.77738807,
        0.03013952, -0.03744685, -0.56171895
    };
    float expected_out[batch * out_c * out_height * out_width] = {13.0, 5.0, -1.0, -7.0, 1.0, 5.0, 5.0, -3.0, -1.0, 5.0, -3.0, -3.0, -7.0, 1.0, -5.0, 5.0, 5.0, 5.0, 3.0, 11.0, 1.0, -1.0, -5.0, 3.0, 5.0, -3.0, 1.0, 1.0, 1.0, -5.0, -3.0, -7.0, -3.0, 5.0, -7.0, -1.0, 1.0, 1.0, -3.0, -3.0, 5.0, -1.0, -5.0, 7.0, -5.0, 3.0, 7.0, -7.0};
    Halide::Buffer<float> in_view(in, width, height, in_c, batch);
    BConvLayer dut (k, 1, in_c, out_c);
    dut.load_weights(W);
    dut.forward_t(out_view, in_view);
    for (int i = 0; i < batch * out_c * out_height * out_width; ++i) {
        if (fabsf(out[i] - expected_out[i]) > 1E-3f) {
            std::cerr << "conv_forward_backward failed at forward_t " << i;
            std::cerr << ". Expected: " << expected_out[i] << " got: " << out[i] << std::endl;
            return -1;
        }
    }
    return 0;
}